
[그래프]

  연결관계가 있는 자료구조
  연결관계간의 최단 경로를 계산하는 등 ex) 사회 연결망, 위치 데이터
  ● 기본 용어
    차수 : 두 노드간의 엣지의 갯수
    경로 : 출발노드부터 도착노드까지 가는 방법들
    최단경로 : 두 노드 사이의 거리가 가장 작은 경로
    사이클 : 특정 노드에서 시작해 다시 그 노드로 돌아오는 경로
  ● 종류
    무방향 그래프(undirected graph) ex) 친구관계
    방향 그래프(directed graph) ex) 인스타 팔로우 관계, 도로
      방향 그래프에는 경로에도 방향이 생기게 된다.
      차수 역시 달라지게 된다.

  <가중치 그래프>
      엣지마다 크기가 존재
      경로의 거리개념이 바뀌게 된다. 엣지의 수 -> 엣지 가중치의 합

   <인접행렬>

      노드들끼리 연결되있는지를 나타내는 2차원 리스트
      각 노드를 리스트에 저장해 고유 정수 인덱스를 준다
      노드 * 노드 크기의 행렬 만듬
      엣지 유무 및 가중치에 따라 행렬의 요소를 채운다

   <인접 리스트>
      노드들의 인접 데이터를 리스트에 저장

      ● 효율성을 나타내기 위한 기호들
          V : 모든 노드들의 집합
          E : 모든 엣지들의 집합
          
          
          
          
[그래프 탐색]

하나의 노드를 시작점으로 연결된 노드를 모두 찾는 것
그래프 순회라고도 부름

  1. Breadth First Search (BFS)
    깊이 보다는 너비를 우선적으로 탐색
    시작점에서 가까운 노드를 먼저 탐색
    큐를 이용해서 구현

    ● BFS 알고리즘 구현방법
    
       시작 노드 방문 표시 후 큐에 넣음
       큐에 아무 노드도 없을때까지:
          큐 가장 앞노드를 꺼낸다
          꺼낸 노드에 인접한 노드를 모두 보면서:
            처음 방문한 노드면:
              방문표시를 한다
              큐에 넣는다

    ● 시간복잡도 분석
       노드 전처리 O(V)
       큐에 노드를 넣고 빼는데 걸리는 시간 O(V)
       큐에서 뺀 노드들의 인접한 노드를 도는데 걸리는 시간 O(E)

       총 시간 복잡도 : O(2V + E) -> O(V + E)


  2. Depth First Search(DFS)

    너비 보다는 깊이를 우선적으로 탐색
    스택을 이용해서 구현

    ● DFS 알고리즘 구현방법
    
      시작 노드를 회색 표시 후 스택에 넣음
      스택에 아무 노드도 없을 때까지:
        스택 가장 위 노드를 꺼낸다
        노드를 방문표시한다.
        인접한 노드를 모두 보면서:
          처음 방문한 노드이면:
             회색표시를 한다
             스택에 넣는다


    ● 시간 복잡도
        노드 전처리 O(V)
        스택에 노드를 넣고 빼는데 걸리는 시간 O(V)
        스택에서 뺀 노드의 인접 노드를 도는데 걸리는 시간 O(V)

        총 시간 복잡도 : O(2V + E) -> O(V + E)

[최단 경로 알고리즘]

최단 경로를 구하는 알고리즘

1. BFS 알고리즘

  비가중치 그래프에서만 최단경로 구할 수 있음
  기존의 BFS 알고리즘에 predecessor를 추가

2. Dijkstra 알고리즘

  그래프 노드에 distance, predecessor, complete를 추가로 저장해야한다.
  distance : 특정 노드까지의 최단거리 예상치
  predecessor : 현재 까지 찾은 최단 경로에서의 직전 노드
  complete : 노드까지의 최단 경로를 찾았다고 표시하기 위한 변수
  relaxation : 노드를 방문하면서 해당 노드의 distance, predecessor를 바꾸는 것

  ● 구현 방법
      시작점의 distance를 0으로 predecessor를 NONE으로 한다
      모든 노드가 complete 될 때까지:
        complete하지 않은 노드 중 가장 작은 노드 선택
        이 노드에 인접한 노드 중 complete하지 않은 노드를 돌면서:
          각 엣지를 relax 한다
          현재 노드를 complete 처리한다
